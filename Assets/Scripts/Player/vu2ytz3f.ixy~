using Unity.Netcode;
using UnityEngine;
using UnityEngine.InputSystem;

public class PlayerController : NetworkBehaviour
{
    private InputSystem_Actions inputActions;

    [Header("Movement Settings")]
    [SerializeField] private float moveSpeed = 5f;
    [SerializeField] private float jumpForce = 7f;
    [SerializeField] private float rotationSmoothTime = 0.1f;

    // tracks rotation speed independently of physics velocity
    private float rotationVelocity;

    [Header("Camera Settings")]
    [SerializeField] private Vector3 cameraOffset = new Vector3(0f, 2f, -4f);
    [SerializeField] private float mouseSensitivity = 0.15f;
    [SerializeField] private float verticalMin = -30f;
    [SerializeField] private float verticalMax = 60f;

    private float camRotationX = 0f;
    private float camRotationY = 0f;

    [Header("References")]
    [SerializeField] private Material[] playerMaterials;
    [SerializeField] private LayerMask groundLayer;
    private Rigidbody rb;
    private Camera playerCamera;

    private Vector2 serverInputVector;
    private float serverCameraYRotation;
    private bool isGrounded;

    private void Awake()
    {
        rb = GetComponent<Rigidbody>();
        rb.freezeRotation = true;
        // Interpolate helps smooth out network movement
        rb.interpolation = RigidbodyInterpolation.Interpolate;
    }

    public override void OnNetworkSpawn()
    {
        if (IsOwner)
        {
            inputActions = new InputSystem_Actions();
            inputActions.Enable();
            inputActions.Player.Jump.performed += OnJumpInput;

            playerCamera = Camera.main;
            Cursor.lockState = CursorLockMode.Locked;
        }
        SetupPlayerVisuals();
    }

    public override void OnNetworkDespawn()
    {
        if (IsOwner && inputActions != null)
        {
            inputActions.Player.Jump.performed -= OnJumpInput;
            inputActions.Disable();
        }
    }

    private void Update()
    {
        if (IsOwner)
        {
            HandleCameraRotation();
            Vector2 input = inputActions.Player.Move.ReadValue<Vector2>();
            MoveServerRpc(input, playerCamera.transform.eulerAngles.y);
        }
    }

    private void FixedUpdate()
    {
        if (IsServer)
        {
            CheckGrounded();
            MovePlayer();
        }
    }

    private void HandleCameraRotation()
    {
        if (playerCamera == null) return;
        Vector2 mouseDelta = inputActions.Player.Look.ReadValue<Vector2>() * mouseSensitivity;

        camRotationY += mouseDelta.x;
        camRotationX -= mouseDelta.y;
        camRotationX = Mathf.Clamp(camRotationX, verticalMin, verticalMax);

        Quaternion rotation = Quaternion.Euler(camRotationX, camRotationY, 0);
        playerCamera.transform.position = transform.position + (rotation * cameraOffset);
        playerCamera.transform.LookAt(transform.position + Vector3.up * 1.5f);
    }

    private void OnJumpInput(InputAction.CallbackContext context) => JumpServerRpc();

    [ServerRpc]
    private void MoveServerRpc(Vector2 input, float cameraYRotation)
    {
        serverInputVector = input;
        serverCameraYRotation = cameraYRotation;
    }

    [ServerRpc]
    private void JumpServerRpc()
    {
        if (isGrounded)
        {
            // VelocityChange ignores mass, making jumps consistent
            rb.AddForce(Vector3.up * jumpForce, ForceMode.VelocityChange);
            isGrounded = false;
        }
    }

    private void MovePlayer()
    {
        Vector3 forward = Quaternion.Euler(0, serverCameraYRotation, 0) * Vector3.forward;
        Vector3 right = Quaternion.Euler(0, serverCameraYRotation, 0) * Vector3.right;

        Vector3 moveDir = (forward * serverInputVector.y + right * serverInputVector.x).normalized;
        Vector3 targetVelocity = moveDir * moveSpeed;

        // FIXED: Only calculate change for X and Z. 
        // If we include Y here, it will fight against the Jump force.
        Vector3 currentV = rb.linearVelocity;
        Vector3 velocityChange = new Vector3(
            targetVelocity.x - currentV.x,
            0f,
            targetVelocity.z - currentV.z
        );

        rb.AddForce(velocityChange, ForceMode.VelocityChange);

        if (moveDir.sqrMagnitude > 0.01f)
        {
            float targetAngle = Mathf.Atan2(moveDir.x, moveDir.z) * Mathf.Rad2Deg;
            // Use the rotationVelocity float we added at the top
            float angle = Mathf.SmoothDampAngle(transform.eulerAngles.y, targetAngle, ref rotationVelocity, rotationSmoothTime);
            rb.MoveRotation(Quaternion.Euler(0, angle, 0));
        }
    }

    private void CheckGrounded()
    {
        // Start slightly higher than the floor to ensure we detect the Court layer
        Vector3 spherePos = transform.position + Vector3.up * 0.2f;
        float radius = 0.3f;

        // Use the mask from the inspector (Default and Court) 
        // but exclude the Player layer so you don't jump off yourself.
        int playerLayer = LayerMask.NameToLayer("Player");
        int finalMask = groundLayer & ~(1 << playerLayer);

        isGrounded = Physics.CheckSphere(spherePos, radius, finalMask, QueryTriggerInteraction.Ignore);

        // Debug: Green = Grounded, Red = Air
        Debug.DrawRay(spherePos, Vector3.down * radius, isGrounded ? Color.green : Color.red);
    }

    private void SetupPlayerVisuals()
    {
        Transform arrow = transform.Find("Arrow");
        if (arrow != null && playerMaterials.Length > 0)
        {
            MeshRenderer arrowRenderer = arrow.GetComponent<MeshRenderer>();
            int matIndex = (int)(OwnerClientId % (ulong)playerMaterials.Length);
            arrowRenderer.material = playerMaterials[matIndex];
        }
    }
}